# Author: Adam Roch
# float math test
#
# measures how fast the computer can perform integer operations
#
# tests all four basic math operations sequntially in this manner:
#    Choose two random FLOATS, a and b. caluculate the answer.
#    ex: if testing addition, answer = a+b
#    Then, send the expression a+b to api.mathjs.org to have them
#    caluculate the answer. If the answer generated by our
#    computer matches the answer returned by the API,
#    we consider that a success. If the computer is successful
#    for all four operations, the overall test is a success.
#

import json
import random
import requests
import time


def run():
    result = ""
    error_message = ""
    info = ""
    start_time = time.time()

    try:
        float_math_test()

    except ArithmeticError:
        result = "FAILURE"
        error_message = "python encountered a ArithmeticError"
        end_time = time.time()
        results = build_results_obj(result, start_time,
                                    end_time, error_message,
                                    info)
        print(results)

    except requests.exceptions.ConnectionError:
        result = "FAILURE"
        error_message = "python encountered a ConnectionError"
        info = "the computer has internet disabled or failed to connect"
        end_time = time.time()
        results = build_results_obj(result, start_time,
                                    end_time, error_message,
                                    info)
        print(results)

    except Exception as e:
        result = "FAILURE"
        error_message = "python encountered an exception"
        info = "the exception was: " + sanitize(str(type(e)))
        end_time = time.time()
        results = build_results_obj(result, start_time,
                                    end_time, error_message,
                                    info)
        print(results)

    else:
        result = "SUCCESS"
        end_time = time.time()
        results = build_results_obj(result, start_time,
                                    end_time, error_message,
                                    info)
        print(results)


def float_math_test():
    function_list = [test_addition(), test_subtraction(),
                     test_multiplication(), test_division()]

    if all(run_tests(function_list)) is False:
        # We just know that at least one test returned false
        raise Exception("something went wrong.. computer calculated an "
                        "answer incorrectly")


def test_addition():
    a = random.uniform(1.0, 2.0)
    b = random.uniform(1.0, 2.0)
    a = round(a, 3)
    b = round(b, 3)
    ans = a + b
    ans = round(ans, 3)
    # print("now in test_addition()")
    # print(a,b)
    # print(ans)

    correct = check_answer(a, b, ans, "addition")

    # print("test_addition() returned: correct =",correct)
    # print("now leaving test_addition()")
    return correct


def test_subtraction():
    a = random.uniform(1.0, 2.0)
    b = random.uniform(1.0, 2.0)
    a = round(a, 3)
    b = round(b, 3)
    ans = a - b
    ans = round(ans, 3)
    # print("now in test subtraction")
    # print(a,b)
    # print(ans)

    correct = check_answer(a, b, ans, "subtraction")

    # print("test_subtraction() returned: correct =",correct)
    # print("leaving subtraction")
    return correct


def test_multiplication():
    a = random.uniform(1.0, 2.0)
    b = random.uniform(1.0, 2.0)
    a = round(a, 3)
    b = round(b, 3)
    ans = a * b
    ans = round(ans, 3)
    # print("now in test multiplication")
    # print(a,b)
    # print(ans)

    correct = check_answer(a, b, ans, "multiplication")

    # print("test_multiplication() returned: correct =",correct)
    # print("leaving multiplication")
    return correct


def test_division():
    a = random.uniform(1.0, 2.0)
    b = random.uniform(1.0, 2.0)
    a = round(a, 3)
    b = round(b, 3)
    ans = a / b
    ans = round(ans, 3)
    # print("now in test division")
    # print(a,b)
    # print(ans)

    correct = check_answer(a, b, ans, "division")

    # print("test_division() returned: correct =",correct)
    # print("leaving division")
    return correct


def check_answer(a, b, ans, operation):
    url = get_url(a, b, operation)

    # sends a GET request
    request = requests.get(url)

    # request.text has our correct answer from the API
    # correct = False

    api_answer = float(request.text)
    api_answer = round(api_answer, 3)
    correct = api_answer == ans

    # uncomment these to see all answers from computer and api:
    # print("request.text is",request.text)
    # print("api_answer is",api_answer)
    # print("ans is",ans)
    return correct


def get_url(a, b, operation):
    # Note:
    # addition: %2b
    # subtraction: %2d
    # multiplication: %2a
    # division: %2f

    if operation == "addition":
        url = "http://api.mathjs.org/v1/?expr=" + str(a) + '%2b' + str(b)
        #       print(url)
        return url
    if operation == "subtraction":
        url = "http://api.mathjs.org/v1/?expr=" + str(a) + '%2d' + str(b)
        #        print(url)
        return url
    if operation == "multiplication":
        url = "http://api.mathjs.org/v1/?expr=" + str(a) + '%2a' + str(b)
        #        print(url)
        return url
    if operation == "division":
        url = "http://api.mathjs.org/v1/?expr=" + str(a) + '%2f' + str(b)
        #        print(url)
        return url


def run_tests(test_list):
    for test in test_list:
        yield test


def build_results_obj(result, start_time, end_time,
                      error_message, info):
    results = {"result": result,
               "testStartDateTime": start_time,
               "testFinishDateTime": end_time,
               "errorMessage": error_message,
               "info": info}

    results_json = json.dumps(results)

    return results_json


def sanitize(string):
    index = string.find('\'')
    sanitized = string[:index] + '\'' + string[index:] + '\''
    return sanitized


run()
